(def input
  "../.. => ###/###/.##
#./.. => ..#/###/##.
##/.. => ..#/##./##.
.#/#. => #../.#./.##
##/#. => #.#/###/.#.
##/## => ##./.../.#.
.../.../... => ...#/.#../#.#./##.#
#../.../... => .#.#/.#../####/###.
.#./.../... => #.##/#.##/.###/##.#
##./.../... => ..##/#.##/.##./..##
#.#/.../... => .#.#/#.#./#..#/...#
###/.../... => #.../.##./.#../.###
.#./#../... => ##.#/...#/##.#/.##.
##./#../... => #.#./###./...#/#.##
..#/#../... => ..##/.###/..../.##.
#.#/#../... => ...#/#..#/#.#./#.#.
.##/#../... => ...#/#.##/..##/.###
###/#../... => .##./..##/##../##.#
.../.#./... => ####/.##./##.#/####
#../.#./... => ..../.##./#..#/##.#
.#./.#./... => ..../#.##/#.../..#.
##./.#./... => .###/.#.#/...#/....
#.#/.#./... => ..##/.#../.###/#.##
###/.#./... => ..../..##/##.#/###.
.#./##./... => .###/.#.#/#..#/#.#.
##./##./... => #..#/#..#/#.##/.##.
..#/##./... => #.##/...#/..#./.##.
#.#/##./... => ..##/#.../..../...#
.##/##./... => ##.#/...#/..##/#..#
###/##./... => ..##/..#./.###/..##
.../#.#/... => .###/..##/.#.#/..##
#../#.#/... => ..##/...#/##../..#.
.#./#.#/... => ..##/##.#/#..#/###.
##./#.#/... => #.../####/..#./#...
#.#/#.#/... => ..../##.#/.##./#..#
###/#.#/... => ..##/#.#./.#.#/.#..
.../###/... => ..##/.#../.#.#/#..#
#../###/... => #.#./.#../.##./....
.#./###/... => ##.#/...#/###./#.##
##./###/... => ..../#.../.###/#.#.
#.#/###/... => ####/..../...#/....
###/###/... => ##.#/##../#.##/#...
..#/.../#.. => ##.#/..#./#.##/..#.
#.#/.../#.. => .#../...#/..#./.##.
.##/.../#.. => ...#/#.../#..#/#..#
###/.../#.. => .###/##../.##./.#..
.##/#../#.. => ..##/#.##/.#.#/...#
###/#../#.. => ...#/.###/..../#..#
..#/.#./#.. => #..#/..../..#./..##
#.#/.#./#.. => #..#/..../#.#./.###
.##/.#./#.. => ..../.##./..##/.#.#
###/.#./#.. => ##.#/###./##.#/..##
.##/##./#.. => #.#./..../###./####
###/##./#.. => #..#/#.##/#.##/#...
#../..#/#.. => ##../#..#/#.../###.
.#./..#/#.. => #.#./.#.#/..../.#.#
##./..#/#.. => #.#./#.../#.#./#..#
#.#/..#/#.. => ..##/.#.#/.#../.###
.##/..#/#.. => ##.#/..##/..../.###
###/..#/#.. => ..#./.##./...#/.#.#
#../#.#/#.. => #.../.#../#.#./##..
.#./#.#/#.. => ..../..../##../#...
##./#.#/#.. => ..#./..../#.../..#.
..#/#.#/#.. => #.#./.#.#/.#../#.##
#.#/#.#/#.. => ...#/##.#/.##./#...
.##/#.#/#.. => ..#./...#/.##./#...
###/#.#/#.. => ..##/#..#/..../..##
#../.##/#.. => ##.#/##.#/#.##/.#.#
.#./.##/#.. => ..##/##../#.#./####
##./.##/#.. => #.#./..../..##/#.##
#.#/.##/#.. => ..#./###./##.#/##.#
.##/.##/#.. => #..#/...#/..##/....
###/.##/#.. => ..##/##../##.#/#.##
#../###/#.. => ####/###./.###/....
.#./###/#.. => ...#/.##./...#/#.##
##./###/#.. => ...#/...#/##.#/.##.
..#/###/#.. => ..##/.##./#.#./...#
#.#/###/#.. => .###/.##./.###/.#.#
.##/###/#.. => ##../.#../#.#./##.#
###/###/#.. => ..../..../.###/##..
.#./#.#/.#. => ##.#/##.#/..##/.##.
##./#.#/.#. => .#../#.##/#.##/#.#.
#.#/#.#/.#. => ..##/#.#./#.../..##
###/#.#/.#. => ##.#/.#.#/##.#/.###
.#./###/.#. => #.#./..#./..##/.##.
##./###/.#. => ...#/#.##/###./#.##
#.#/###/.#. => ...#/.###/#.#./#.#.
###/###/.#. => .#.#/#..#/####/#...
#.#/..#/##. => #.##/#.#./##../####
###/..#/##. => ##.#/...#/..../####
.##/#.#/##. => #.../#..#/..##/....
###/#.#/##. => ##../###./...#/####
#.#/.##/##. => ##.#/..##/..../#...
###/.##/##. => ..#./####/..../#...
.##/###/##. => ..##/#.##/..#./####
###/###/##. => #.##/...#/..../..#.
#.#/.../#.# => ..#./#.##/#..#/#.#.
###/.../#.# => ..#./###./..##/#...
###/#../#.# => .###/#..#/##../.#..
#.#/.#./#.# => ###./##.#/.#../#..#
###/.#./#.# => ##.#/###./#.../...#
###/##./#.# => ####/##../#.../....
#.#/#.#/#.# => ..#./..##/..#./...#
###/#.#/#.# => ...#/##.#/##.#/#.##
#.#/###/#.# => ..#./####/.#../##.#
###/###/#.# => ..../.#.#/..../...#
###/#.#/### => #.#./..##/##.#/....
###/###/### => ..#./#.##/####/###.")

(require '[clojure.core.matrix :as m]
         '[clojure.math.combinatorics :as combo])

(m/set-current-implementation :vectorz)

(set! *warn-on-reflection* true)
(set! *unchecked-math* :warn-on-boxed)

(defn- mirror-horizontally [m]
  (let [size (long (-> m
                       m/shape
                       first))]
    (m/matrix
     (map (partial map int)
          (m/mmul (case size
                    2 (m/matrix [[0 1] [1 0]])
                    3 (m/matrix [[0 0 1] [0 1 0] [1 0 0]]))

                  m)))))

(defn- all-input-patterns [m]
  (->> [m 0]

       (iterate (fn [[m ^long i]]
                  [(if (even? i) (m/transpose m) (mirror-horizontally m))
                   (inc i)]))

       (take 8)
       (map first)))

(defn- string->vector [s]
  (->> s
       (re-seq #"[\\.#]")
       (map #(case % "." 0 "#" 1))
       m/matrix))

(defn- string->matrix [s]
  (let [rows (->> s
                  (re-seq #"[\\.#]+")
                  (map string->vector))]
    (->> rows
         (map m/row-matrix)
         (reduce #(m/join-along 0 %1 %2))
         m/matrix)))

(defn- all-rules-for-patterns [from to]
  (into {} (zipmap (all-input-patterns from) (repeat to))))

(defn- build-rules [input]
  (apply merge
         (for [[_ from to] (re-seq #"([\\.#/]+)\s=>\s([\\.#/]+)" input)
               :let [from (string->matrix from)
                     to (string->matrix to)]]
           (all-rules-for-patterns from to))))

(defn- split-matrix [^long n m]
  (let [size (long (-> m
                       m/shape
                       first))

        start-indices (range 0 (inc (- size n)) n)
        ranges (map #(range % (+ ^long % n)) start-indices)
        selection-pairs (combo/selections ranges 2)]
    (pmap #(->> %
                (apply m/select-view m)
                m/matrix)
          selection-pairs)))

(def initial (m/matrix [[0 1 0]
                        [0 0 1]
                        [1 1 1]]))

(def rules (build-rules input))

(defn- transform [rules m]
  (let [size (long (-> m
                       m/shape
                       first))
        split-size (if (even? size) 2 3)
        ms (split-matrix split-size m)
        transformed-ms (pmap (partial rules) ms)]
    (m/matrix
     (if (= 1 (count transformed-ms))
       (first transformed-ms)

       (apply m/join-along 0
              (->> transformed-ms
                   (partition (quot size split-size))
                   (pmap (partial apply m/join-along 1))))))))

(defn- set-bit-count [m]
  (->> m
       (map (partial reduce +))
       (reduce +)
       int))

(def matrices (iterate (partial transform rules) initial))

(->> 18
     (nth matrices)
     set-bit-count)
